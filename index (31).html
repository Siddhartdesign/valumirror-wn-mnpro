<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Viewfinder ‚Äì Tool</title>

<style>
  :root {
    --bg: #050505;
    --panel: rgba(10,10,10,0.75);
    --panel-soft: rgba(10,10,10,0.55);
    --border: rgba(255,255,255,0.14);
    --border-strong: rgba(255,255,255,0.26);
    --text: rgba(255,255,255,0.94);
    --muted: rgba(255,255,255,0.6);
    --accent: #4fd1ff;
    --danger: #ff7b7b;
  }

  * {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }

  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: radial-gradient(circle at top, #16181f 0, #050507 45%, #000 100%);
    color: var(--text);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  /* VIDEO & CANVAS */
  #video, #canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* TOP BAR ‚Äì full width, subtle glass */
  #topbar {
    position: fixed;
    top: 10px;
    left: 10px;
    right: 10px;
    padding: 6px;
    border-radius: 14px;
    background: var(--panel);
    border: 1px solid var(--border);
    backdrop-filter: blur(14px);
    -webkit-backdrop-filter: blur(14px);
    z-index: 50;
    display: flex;
    gap: 6px;
    flex-wrap: nowrap;
    justify-content: space-between;
    align-items: center;
  }

  /* Performance: disable blur when camera is active */
  body.camera-active #topbar,
  body.camera-active #bottombar {
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
  }

  /* BOTTOM BAR ‚Äì centered cluster */
 #bottombar {
  position: fixed;
  bottom: 15px;
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 12px;
  border-radius: 18px;
  background: var(--panel);
  border: 1px solid var(--border);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  z-index: 50;

  display: flex;
  gap: 8px;
  flex-wrap: nowrap;
  align-items: center;
  justify-content: center;

  width: max-content;
  max-width: calc(100vw - 30px); /* More margin to prevent bleeding */
}


  /* BUTTONS */
  .btn {
  appearance: none;
  background: rgba(255,255,255,0.06);
  color: var(--text);
  border: 1px solid var(--border);
  padding: 7px 10px;
  border-radius: 10px;
  cursor: pointer;
  user-select: none;
  font-size: 12px;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px; /* Space between icon and text */
  min-width: 36px;
  transition:
    background 0.15s ease,
    border-color 0.15s ease,
    transform 0.1s ease,
    box-shadow 0.15s ease;
}

  /* Button text labels - hidden by default on mobile */
  .btn-label {
    display: none;
  }
  
  /* Mobile-specific: Show ratio text in frame button instead of emoji */
  #frameFab .btn-icon {
    display: none; /* Hide emoji on mobile */
  }
  
  #frameFab .btn-label {
    display: inline; /* Show ratio text on mobile */
    color: var(--accent); /* Keep cyan color */
  }
  
  /* Mobile-specific: Show "Custom" text instead of gear emoji */
  #customRatioBtn .btn-icon {
    display: none; /* Hide gear emoji on mobile */
  }
  
  #customRatioBtn .btn-label {
    display: inline; /* Show "Custom" text on mobile */
    color: var(--accent); /* Match cyan color of frame ratio */
  }
  
  /* Mobile-specific: Show "Clear" text instead of bin emoji */
  #clearImgBtn .btn-icon {
    display: none;
  }
  
  #clearImgBtn .btn-label {
    display: inline;
  }

  .btn:hover {
    background: rgba(255,255,255,0.12);
    border-color: var(--border-strong);
    box-shadow: 0 0 0 1px rgba(255,255,255,0.06);
  }

  .btn:active {
    transform: scale(0.96);
    box-shadow: none;
  }

  .btn.active {
    background: rgba(79,209,255,0.18);
    border-color: rgba(79,209,255,0.5);
    color: var(--accent);
    box-shadow: 0 0 0 1px rgba(79,209,255,0.35);
  }

  .btn.primary {
    color: var(--accent);
  }

  .btn.danger {
    color: var(--danger);
    border-color: rgba(255,123,123,0.5);
  }

  /* TEMPORARY - Call to action button styles */
  #exportBtn {
    background: rgba(79,209,255,0.15);
    border-color: rgba(79,209,255,0.4);
    color: var(--accent);
  }

  #exportBtn:hover {
    background: rgba(79,209,255,0.22);
    border-color: rgba(79,209,255,0.6);
  }

  #loadImgBtn {
    background: rgba(34,197,94,0.15);
    border-color: rgba(34,197,94,0.4);
    color: rgb(134,239,172);
  }

  #loadImgBtn:hover {
    background: rgba(34,197,94,0.22);
    border-color: rgba(34,197,94,0.6);
  }

  #customRatioBtn .btn-label {
    color: var(--accent);
  }

  /* NOTE TAG (frame readout) */
  #note {
    position: fixed;
    top: 54px;            /* sits just under top bar */
    left: 12px;
    padding: 6px 10px;
    background: var(--panel-soft);
    border-radius: 12px;
    border: 1px solid var(--border);
    color: var(--muted);
    z-index: 55;
    font-size: 11.5px;
    letter-spacing: 0.02em;
  }

  /* CUSTOM RATIO MODAL */
  #modalCustom {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.55);
    z-index: 9999;
  }

  #modalCustomInner {
    width: 260px;
    background: var(--panel);
    border-radius: 16px;
    padding: 14px;
    border: 1px solid var(--border-strong);
    box-shadow:
      0 18px 45px rgba(0,0,0,0.65),
      0 0 0 1px rgba(255,255,255,0.04);
  }

  #modalCustomInner h3 {
    margin: 0 0 8px 0;
    font-size: 13px;
    font-weight: 500;
    color: var(--muted);
  }

  #modalCustomInner input,
  #modalCustomInner select {
    width: 100%;
    padding: 7px 9px;
    margin-top: 6px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.05);
    color: var(--text);
    font-size: 12px;
  }

  .modalBtn {
    width: 100%;
    margin-top: 8px;
    padding: 9px;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.08);
    color: var(--text);
    cursor: pointer;
    font-size: 12px;
  }

  .modalBtn:hover {
    background: rgba(255,255,255,0.13);
  }

  input[type="file"] { display:none; }
  /* BG PALETTE ‚Äî under üëÅ */
#bgPalette {
  position: fixed;
  top: 54px;
  left: 50%;
  transform: translateX(-50%);
  display: none;
  gap: 8px;
  padding: 8px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  z-index: 60;
}


#bgPalette button {
  width: 22px;
  height: 22px;
  display: block;
  padding: 0;

  background-clip: padding-box;
  border-radius: 5px;
  border: 1px solid var(--border-strong);
  cursor: pointer;
  appearance: none;
  -webkit-appearance: none;
}
  /* bottom buttons biggers */
  #bottombar .btn {
  padding: 11px 15px;   /* makes buttons bigger */
  font-size: 13.5px;    /* slightly more legible */
  min-width: 44px;      /* better tap target */
  border-radius: 12px;  /* matches increased size */
}


  /* spacer */
  .group-gap {
  width: 10px;
  height: 1px;
}
/* ===== HELP AFFORDANCE (SAFE LAYER) ===== */
#helpHint{
  position: fixed;
  z-index: 91;
  opacity: 0.75;
    user-select: none;
  -webkit-user-select: none;
}



.help-overlay {
  position: fixed;
  inset: 0;
  z-index: 90;
  pointer-events: auto;
}

.help-label {
  position: absolute;
  padding: 6px 9px;
  font-size: 11px;
  border-radius: 9px;
  background: rgba(12,12,12,0.88);
  border: 1px solid rgba(255,255,255,0.18);
  color: rgba(255,255,255,0.92);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  white-space: nowrap;
  box-shadow: 0 8px 22px rgba(0,0,0,0.55);

  /* Mobile: vertical rotation */
  transform: translate(-50%, -120%) rotate(-90deg);
  transform-origin: left center;
}

/* ============================================
   DESKTOP OPTIMIZATIONS (1024px and up)
   ============================================ */
@media (min-width: 1024px) {
  /* Show text labels next to icons on desktop */
  .btn-label {
    display: inline;
  }
  
  /* Desktop: Show frame emoji AND text */
  #frameFab .btn-icon {
    display: inline;
  }
  
  #frameFab .btn-label {
    display: inline;
  }
  
  /* Desktop: Show gear emoji AND "Custom Frame" text */
  #customRatioBtn .btn-icon {
    display: inline;
  }
  
  #customRatioBtn .btn-label {
    display: inline;
  }
  
  /* Desktop: Show bin emoji AND text */
  #clearImgBtn .btn-icon {
    display: inline;
  }
  
  #clearImgBtn .btn-label {
    display: inline;
  }
  
  /* Restore desktop bottom bar spacing */
  #bottombar {
    padding: 14px 18px;
    gap: 12px;
  }

  /* Make buttons bigger on desktop for better click targets */
  #topbar .btn {
    padding: 9px 14px;
    font-size: 14px;
    min-width: auto;
  }

  #bottombar .btn {
    padding: 12px 18px;
    font-size: 15px;
    min-width: auto;
  }

  /* Make icons slightly larger on desktop */
  .btn-icon {
    font-size: 16px;
  }

  /* Horizontal help hints on desktop */
  .help-label {
    transform: translate(-50%, -120%);
    transform-origin: center;
    font-size: 12px;
    padding: 7px 11px;
  }

  /* Slightly larger frame note on desktop */
  #note {
    font-size: 12.5px;
    padding: 7px 12px;
  }

  /* Larger gap between button groups */
  .group-gap {
    width: 14px;
  }
}

/* ============================================
   NOTE 9 SIZE PHONES (401-420px)
   Balance horizontal/vertical padding on bottom bar
   ============================================ */
@media (min-width: 401px) and (max-width: 420px) {
  #bottombar {
    padding: 10px 16px; /* More horizontal padding to match vertical */
  }
}

/* ============================================
   SMALL PHONES ONLY (iPhone 13 and smaller)
   Note 9 (~412px) and Desktop remain unchanged
   ============================================ */
@media (max-width: 400px) {
  /* Smaller padding and gap for bottom bar to prevent bleeding */
  #bottombar {
    padding: 8px 10px;
    gap: 6px;
    max-width: calc(100vw - 40px);
  }
  
  #bottombar .btn {
    padding: 9px 12px;
    min-width: 38px;
  }
  
  /* Smaller top bar padding */
  #topbar {
    padding: 5px;
    gap: 5px;
  }
  
  #topbar .btn {
    padding: 6px 8px;
    font-size: 11px;
  }
}

/* ============================================
   HELP CARD - Instructions
   ============================================ */
#helpCard {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90%;
  max-width: 420px;
  max-height: 85vh;
  overflow-y: auto;
  background: rgba(12,12,12,0.95);
  border: 1px solid var(--border-strong);
  border-radius: 18px;
  padding: 24px 28px;
  z-index: 9998;
  display: none;
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  box-shadow: 0 20px 60px rgba(0,0,0,0.8);
  user-select: none;
  -webkit-user-select: none;
}

#helpCard h2 {
  margin: 0 0 8px 0;
  font-size: 18px;
  font-weight: 600;
  color: var(--text);
  letter-spacing: -0.01em;
}

#helpCard h3 {
  margin: 0 0 4px 0;
  font-size: 15px;
  font-weight: 600;
  color: var(--text);
}

#helpCard p {
  margin: 0 0 16px 0;
  font-size: 13px;
  line-height: 1.5;
  color: var(--muted);
}

#helpCard hr {
  border: none;
  border-top: 1px solid var(--border);
  margin: 18px 0;
}

#helpCard ul {
  margin: 8px 0 16px 0;
  padding-left: 20px;
  list-style: none;
}

#helpCard li {
  font-size: 13px;
  line-height: 1.6;
  color: var(--muted);
  margin-bottom: 6px;
  position: relative;
}

#helpCard li:before {
  content: "‚Ä¢";
  position: absolute;
  left: -16px;
  color: var(--accent);
}

#helpCard .final-note {
  font-size: 13px;
  font-style: italic;
  color: var(--muted);
  margin-top: 12px;
}

#helpCardClose {
  position: absolute;
  top: 16px;
  right: 16px;
  background: rgba(255,255,255,0.08);
  border: 1px solid var(--border);
  border-radius: 8px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 18px;
  color: var(--text);
  transition: background 0.15s ease;
}

#helpCardClose:hover {
  background: rgba(255,255,255,0.12);
}

#helpCardOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 9997;
  display: none;
}

/* TEMPORARY - Welcome message */
#welcomeMsg {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 16px;
  color: rgba(255,255,255,0.55);
  text-align: center;
  pointer-events: none;
  z-index: 10;
  max-width: 80%;
  line-height: 1.6;
  font-weight: 400;
  letter-spacing: 0.01em;
}

@media (min-width: 1024px) {
  #welcomeMsg {
    font-size: 22px;
    color: rgba(255,255,255,0.6);
  }
}


</style>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#050505">
</head>

<body>

<video id="video" autoplay playsinline muted></video>
<canvas id="canvas"></canvas>

<div id="welcomeMsg">Import an image or use the live viewfinder to block-in and compose.</div>

<div id="note">Frame: <span id="currentRatio">1:1</span></div>

<!-- TOP BAR -->
<div id="topbar">
  <button id="loadImgBtn" class="btn" title="Load image">
    <span class="btn-icon">üì∑</span>
    <span class="btn-label">Import Image</span>
  </button>
  <button id="clearImgBtn" class="btn danger" title="Clear image">
    <span class="btn-icon">üóë</span>
    <span class="btn-label">Clear Image</span>
  </button>
<span class="group-gap"></span>

  <button id="toggleCam" class="btn" title="Toggle camera">
    <span class="btn-icon">üëÅ</span>
    <span class="btn-label">Guide Only</span>
  </button>
  <div id="bgPalette">
  <button data-bg="#f3e9d2" title="Warm paper"></button>
  <button data-bg="#ffffff" title="White"></button>
  <button data-bg="#000000" title="Black"></button>
</div>
  <button id="switchBtn" class="btn" title="Switch camera">
    <span class="btn-icon">‚áÑ</span>
    <span class="btn-label">Switch</span>
  </button>
<span class="group-gap"></span>


  <button id="frameFab" class="btn primary" title="Frame preset">
    <span class="btn-icon">üìê</span>
    <span class="btn-label">1:1</span>
  </button>

  <button id="customRatioBtn" class="btn" title="Custom ratio">
    <span class="btn-icon">‚öô</span>
    <span class="btn-label">Custom</span>
  </button>
</div>

<!-- BOTTOM BAR -->
<div id="bottombar">
  <button id="dotBtn" class="btn" title="Place dot">
    <span class="btn-icon">‚Ä¢</span>
    <span class="btn-label">Dot</span>
  </button>
  <button id="vertBtn" class="btn" title="Vertical line">
    <span class="btn-icon">|</span>
    <span class="btn-label">Vertical</span>
  </button>
  <button id="horiBtn" class="btn" title="Horizontal line">
    <span class="btn-icon">‚Äî</span>
    <span class="btn-label">Horizontal</span>
  </button>
  <button id="slantBtn" class="btn" title="Slant line">
    <span class="btn-icon">/</span>
    <span class="btn-label">Slant</span>
  </button>
<span class="group-gap"></span>

  <button id="deleteBtn" class="btn danger" title="Delete selected">
    <span class="btn-icon">√ó</span>
    <span class="btn-label">Delete</span>
  </button>
<span class="group-gap"></span>

  <button id="exportBtn" class="btn primary" title="Export image">
    <span class="btn-icon">üì•</span>
    <span class="btn-label">Export Image</span>
  </button>

  <button id="helpBtn" class="btn" title="Help">
    <span class="btn-icon">?</span>
  </button>
</div>

<!-- Custom Ratio Modal -->
<div id="modalCustom">
  <div id="modalCustomInner">
    <h3>Custom Ratio</h3>
    <input id="crW" type="number" placeholder="Width" value="16" step="0.1">
    <input id="crH" type="number" placeholder="Height" value="9" step="0.1">
    <select id="crUnit">
      <option value="ratio">Ratio</option>
      <option value="mm">Millimeters</option>
      <option value="in">Inches</option>
    </select>
    <button id="crApply" class="modalBtn">Apply</button>
    <button id="crClose" class="modalBtn">Cancel</button>
  </div>
</div>

<!-- Help Card -->
<div id="helpCardOverlay"></div>
<div id="helpCard">
  <button id="helpCardClose">√ó</button>
  <h2>How Viewfinder+ Works</h2>
  <p>Viewfinder+ is a block-in and composition tool.<br>
  For any canvas or sketchbook size.<br>
  It helps you set up structure before drawing.</p>
  
  <hr>
  
  <h3>1. Frame the Subject</h3>
  <ul>
    <li>Start with the live camera or an imported image</li>
    <li>Define composition using the Frame tool</li>
    <li>Customize the frame to match your exact canvas or sketchbook size</li>
    <li>Use custom ratios to compose precisely for your final surface</li>
  </ul>
  
  <hr>
  
  <h3>2. Block-In for Artists</h3>
  <p style="margin: 8px 0 12px 0;">Use guides to establish structure ‚Äî not details.</p>
  <p style="margin: 0 0 8px 0; font-weight: 600; color: var(--text);">Block-in tools:</p>
  <ul>
    <li><strong>Dot</strong> ‚Äî key landmarks and reference points</li>
    <li><strong>Plumb line</strong> ‚Äî true vertical or horizontal reference</li>
    <li><strong>Horizontal line</strong> ‚Äî eye level, horizons, alignments</li>
    <li><strong>Slant line (freeform tool)</strong> ‚Äî two-point, draggable line for complex angles (power tool)</li>
  </ul>
  <p style="margin: 8px 0 0 0; font-size: 12px;">These tools are for layout, proportion, and spatial relationships.</p>
  
  <hr>
  
  <h3>3. Adjust Guides</h3>
  <ul>
    <li>Select any guide to move or refine it</li>
    <li>Remove guides using the delete control next to the selection</li>
  </ul>
  
  <hr>
  
  <h3>4. Guides-Only Mode</h3>
  <ul>
    <li>Hide the background to view clean block-in guides</li>
    <li>Adjust background control when exporting guides only for better visibility</li>
  </ul>
  
  <hr>
  
  <h3>5. Save / Export</h3>
  <ul>
    <li>Save your annotated view as an image</li>
    <li>Export:
      <ul style="margin: 4px 0 0 20px; padding: 0;">
        <li>Image with guides</li>
        <li>Guides only (clean block-in reference)</li>
      </ul>
    </li>
  </ul>
  
  <hr>
  
  <h3>Help Hints</h3>
  <ul>
    <li>Touch & hold "?" anywhere to see tool hints</li>
  </ul>
  
  <hr>
  
  <p class="final-note">This app sets structure.<br>You do the drawing. Have fun!</p>
</div>

<input type="file" id="imgInput" accept="image/*">

<script>
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const DPR = window.devicePixelRatio || 1;

const loadImgBtn = document.getElementById("loadImgBtn");
const clearImgBtn = document.getElementById("clearImgBtn");
const toggleCam = document.getElementById("toggleCam");
const switchBtn = document.getElementById("switchBtn");
const frameFab = document.getElementById("frameFab");
const customRatioBtn = document.getElementById("customRatioBtn");
const dotBtn = document.getElementById("dotBtn");
const vertBtn = document.getElementById("vertBtn");
const horiBtn = document.getElementById("horiBtn");
const slantBtn = document.getElementById("slantBtn");
const deleteBtn = document.getElementById("deleteBtn");
const exportBtn = document.getElementById("exportBtn");
const helpBtn = document.getElementById("helpBtn");

const imgInput = document.getElementById("imgInput");
const currentRatioLabel = document.getElementById("currentRatio");

const modalCustom = document.getElementById("modalCustom");
const crW = document.getElementById("crW");
const crH = document.getElementById("crH");
const crUnit = document.getElementById("crUnit");
const crApply = document.getElementById("crApply");
const crClose = document.getElementById("crClose");

let devices = [];
let currentDeviceIndex = 0;
let stream = null;
let videoHidden = false;
let bgImage = null;
let gridBg = "#000000";

// Performance: Cache imported image position/scale
let bgImageCache = null;

let mode = null;
let dots = [];
let lines = [];
let selected = null;
let isDragging = false;
let dragOffset = {x:0, y:0};

let frame = {x:0, y:0, w:0, h:0, ratio:1};

const frameList = [
  {label:"1:1", value:1},
  {label:"4:3", value:4/3},
  {label:"3:2", value:3/2},
  {label:"16:9", value:16/9},
  {label:"2:3", value:2/3},
  {label:"9:16", value:9/16}
];
let frameIndex = 0;

/* -------- Camera -------- */
async function getDevices(){
  try {
    const all = await navigator.mediaDevices.enumerateDevices();
    devices = all.filter(d=>d.kind==="videoinput");
    if(!devices.length) devices=[{deviceId:null}];
  } catch {
    devices=[{deviceId:null}];
  }
}

async function startCamera(){
  if(stream) stream.getTracks().forEach(t=>t.stop());

  const dId = devices[currentDeviceIndex]?.deviceId;
  const constraints = dId
    ? {video:{deviceId:{exact:dId}, facingMode:"environment"}}
    : {video:{facingMode:"environment"}};

  try {
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
  } catch {}
}

async function switchCamera(){
  if(devices.length <= 1) return;
  currentDeviceIndex = (currentDeviceIndex+1) % devices.length;
  await startCamera();
}

/* -------- Frame -------- */
function resizeCanvas(){
  const w = window.innerWidth, h = window.innerHeight;
  
  // Set display size (CSS pixels)
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  
  // Performance: Use lower DPR for live camera, full DPR for imported images
  const effectiveDPR = (bgImage || videoHidden) ? DPR : 1;
  
  // Set actual canvas size (accounting for DPR for high DPI displays)
  canvas.width = w * effectiveDPR;
  canvas.height = h * effectiveDPR;
  
  // Scale all drawing operations by effectiveDPR
  ctx.scale(effectiveDPR, effectiveDPR);

  const pad = 0.05;
  const maxW = w * (1 - pad*2);
  const maxH = h * (1 - pad*2);

  let fw, fh;
  if(maxW / maxH > frame.ratio){
    fh = maxH;
    fw = fh * frame.ratio;
  } else {
    fw = maxW;
    fh = fw / frame.ratio;
  }

  frame.w = fw;
  frame.h = fh;
  frame.x = (w - fw) / 2;
  frame.y = (h - fh) / 2;
}
window.addEventListener("resize", resizeCanvas);

/* -------- Draw -------- */
function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }

function pointToSegmentDistance(px,py,x1,y1,x2,y2){
  const A=px-x1,B=py-y1,C=x2-x1,D=y2-y1;
  const dot=A*C+B*D, lenSq=C*C+D*D;
  let t=(lenSq!==0)? dot/lenSq : -1;
  if(t<0){ return Math.hypot(px-x1,py-y1); }
  if(t>1){ return Math.hypot(px-x2,py-y2); }
  return Math.hypot(px-(x1+t*C),py-(y1+t*D));
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Draw background (video or solid color)
  if(!videoHidden && video.readyState >= video.HAVE_CURRENT_DATA){
    // If user has imported an image, show black outside frame instead of camera
    if(bgImage){
      ctx.fillStyle = "#000000";
      ctx.fillRect(0,0,canvas.width,canvas.height);
    } else {
      ctx.drawImage(video,0,0,canvas.width,canvas.height);
    }
  } else {
    ctx.fillStyle = gridBg;
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // Draw the frame overlay (darkens everything outside the frame)
  ctx.save();
  ctx.fillStyle="rgba(0,0,0,0.7)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.clearRect(frame.x,frame.y,frame.w,frame.h);
  ctx.restore();

  // Draw imported image inside the frame ONLY if camera is not hidden
  if(bgImage && !videoHidden){
    ctx.save();
    
    // First, fill the entire frame with black to cover any camera feed gaps
    ctx.fillStyle = "#000000";
    ctx.fillRect(frame.x, frame.y, frame.w, frame.h);
    
    // Then draw the imported image on top
    ctx.beginPath();
    ctx.rect(frame.x,frame.y,frame.w,frame.h);
    ctx.clip();
    
    // Performance: Use cached calculations or compute if cache invalid
    if(!bgImageCache || bgImageCache.frameW !== frame.w || bgImageCache.frameH !== frame.h){
      const iw=bgImage.width, ih=bgImage.height;
      const scale = Math.min(frame.w/iw, frame.h/ih);
      const dw=iw*scale, dh=ih*scale;
      bgImageCache = {
        frameW: frame.w,
        frameH: frame.h,
        dw: dw,
        dh: dh,
        dx: frame.x+(frame.w-dw)/2,
        dy: frame.y+(frame.h-dh)/2
      };
    }
    
    ctx.drawImage(bgImage, bgImageCache.dx, bgImageCache.dy, bgImageCache.dw, bgImageCache.dh);
    ctx.restore();
  }

  // If camera/video is hidden, fill the frame with the selected background color
  if(videoHidden){
    ctx.fillStyle = gridBg;
    ctx.fillRect(frame.x, frame.y, frame.w, frame.h);
  }

  // Draw frame border
  ctx.strokeStyle="rgba(255,255,255,0.85)";
  ctx.lineWidth=2;
  ctx.strokeRect(frame.x,frame.y,frame.w,frame.h);

  for(let i=0;i<dots.length;i++){
    const d = dots[i];
    if(selected && selected.type==="dot" && selected.idx===i){
      ctx.fillStyle="rgba(0,200,255,0.95)";
      ctx.beginPath(); ctx.arc(d.x,d.y,8,0,Math.PI*2); ctx.fill();
    } else {
      ctx.fillStyle="rgba(255,255,255,0.9)";
      ctx.beginPath(); ctx.arc(d.x,d.y,6,0,Math.PI*2); ctx.fill();
    }
  }

  for(let i=0;i<lines.length;i++){
    const ln = lines[i];

    if(selected && selected.type==="line" && selected.idx===i){
      ctx.save();
      ctx.strokeStyle="rgba(0,180,255,0.18)";
      ctx.lineWidth=10;
      ctx.lineCap="round";
      ctx.beginPath();
      if(ln.type==="vert"){
        ctx.moveTo(ln.x,frame.y); ctx.lineTo(ln.x,frame.y+frame.h);
      } else if(ln.type==="hori"){
        ctx.moveTo(frame.x,ln.y); ctx.lineTo(frame.x+frame.w,ln.y);
      } else {
        ctx.moveTo(ln.x1,ln.y1); ctx.lineTo(ln.x2,ln.y2);
      }
      ctx.stroke();
      ctx.restore();

      ctx.strokeStyle="rgba(0,200,255,0.95)";
      ctx.lineWidth=3;
    } else {
      ctx.strokeStyle="rgba(255,255,255,0.9)";
      ctx.lineWidth=2.5;
    }

    ctx.beginPath();
    if(ln.type==="vert"){
      ctx.moveTo(ln.x,frame.y); ctx.lineTo(ln.x,frame.y+frame.h);
    } else if(ln.type==="hori"){
      ctx.moveTo(frame.x,ln.y); ctx.lineTo(frame.x+frame.w,ln.y);
    } else {
      ctx.moveTo(ln.x1,ln.y1); ctx.lineTo(ln.x2,ln.y2);
    }
    ctx.stroke();

    if(ln.type==="slant"){
      ctx.fillStyle="rgba(255,255,255,0.9)";
      ctx.beginPath(); ctx.arc(ln.x1,ln.y1,6,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(ln.x2,ln.y2,6,0,Math.PI*2); ctx.fill();
    }
  }

  requestAnimationFrame(draw);
}

/* -------- Pointer handling -------- */
function screenToCanvas(e){
  const r = canvas.getBoundingClientRect();
  const x = (e.clientX ?? e.touches?.[0]?.clientX) - r.left;
  const y = (e.clientY ?? e.touches?.[0]?.clientY) - r.top;
  return {x,y};
}

function findNearestDot(x,y){
  for(let i=0;i<dots.length;i++){
    if(dist(x,y,dots[i].x,dots[i].y) < 12) return i;
  }
  return -1;
}

function findNearestLine(x,y){
  for(let i=lines.length-1;i>=0;i--){
    const ln = lines[i];
    if(ln.type==="slant"){
      if(dist(x,y,ln.x1,ln.y1)<12) return {idx:i, part:"p1"};
      if(dist(x,y,ln.x2,ln.y2)<12) return {idx:i, part:"p2"};
      const d = pointToSegmentDistance(x,y,ln.x1,ln.y1,ln.x2,ln.y2);
      if(d < 8) return {idx:i, part:"body"};
    } else if(ln.type==="vert"){
      if(Math.abs(x-ln.x)<8 && y>frame.y && y<frame.y+frame.h) return {idx:i, part:"body"};
    } else if(ln.type==="hori"){
      if(Math.abs(y-ln.y)<8 && x>frame.x && x<frame.x+frame.w) return {idx:i, part:"body"};
    }
  }
  return null;
}

canvas.addEventListener("mousedown", e=>{
  const p = screenToCanvas(e);
  onPointerDown(p.x,p.y);
});
canvas.addEventListener("touchstart", e=>{
  e.preventDefault();
  const p = screenToCanvas(e);
  onPointerDown(p.x,p.y);
},{passive:false});

function onPointerDown(x,y){
  isDragging = true;
  
  // Hide welcome message on first interaction
  document.getElementById("welcomeMsg").style.display = "none";

  const dIdx = findNearestDot(x,y);
  if(dIdx >= 0){
    selected = {type:"dot", idx:dIdx};
    return;
  }

  const lnHit = findNearestLine(x,y);
  if(lnHit){
    selected = {type:"line", idx:lnHit.idx, sub:lnHit.part};
    const ln = lines[lnHit.idx];
    if(lnHit.part==="body" && ln){
      if(ln.type==="slant"){
        dragOffset.x = x;
        dragOffset.y = y;
      } else if(ln.type==="vert"){
        dragOffset.x = ln.x - x;
      } else if(ln.type==="hori"){
        dragOffset.y = ln.y - y;
      }
    }
    return;
  }

  if(mode==="dot"){
    dots.push({x,y});
    selected = {type:"dot", idx:dots.length-1};
  } else if(mode==="vert"){
    const vx = Math.max(frame.x, Math.min(frame.x+frame.w, x));
    lines.push({type:"vert", x:vx});
    selected = {type:"line", idx:lines.length-1, sub:"body"};
  } else if(mode==="hori"){
    const hy = Math.max(frame.y, Math.min(frame.y+frame.h, y));
    lines.push({type:"hori", y:hy});
    selected = {type:"line", idx:lines.length-1, sub:"body"};
  } else if(mode==="slant"){
    const x2 = x + 120;
    const y2 = y + 40;
    lines.push({type:"slant", x1:x, y1:y, x2:x2, y2:y2});
    selected = {type:"line", idx:lines.length-1, sub:"p2"};
  }
}

canvas.addEventListener("mousemove", e=>{
  const p = screenToCanvas(e);
  onPointerMove(p.x,p.y);
});
canvas.addEventListener("touchmove", e=>{
  e.preventDefault();
  const p = screenToCanvas(e);
  onPointerMove(p.x,p.y);
},{passive:false});

function onPointerMove(x,y){
  if(!isDragging || !selected) return;

  if(selected.type==="dot"){
    dots[selected.idx].x = x;
    dots[selected.idx].y = y;
    return;
  }

  const ln = lines[selected.idx];
  if(!ln) return;

  if(selected.sub==="p1"){
    ln.x1 = x; ln.y1 = y;
  } else if(selected.sub==="p2"){
    ln.x2 = x; ln.y2 = y;
  } else if(selected.sub==="body"){
    if(ln.type==="slant"){
      const dx = x - dragOffset.x;
      const dy = y - dragOffset.y;
      ln.x1 += dx; ln.y1 += dy;
      ln.x2 += dx; ln.y2 += dy;
      dragOffset.x = x;
      dragOffset.y = y;
    } else if(ln.type==="vert"){
      ln.x = Math.max(frame.x, Math.min(frame.x+frame.w, x + dragOffset.x));
    } else if(ln.type==="hori"){
      ln.y = Math.max(frame.y, Math.min(frame.y+frame.h, y + dragOffset.y));
    }
  }
}

canvas.addEventListener("mouseup", onPointerUp);
canvas.addEventListener("mouseleave", onPointerUp);
canvas.addEventListener("touchend", onPointerUp);

function onPointerUp(){
  isDragging = false;
  if(selected && selected.type==="line"){
    const ln = lines[selected.idx];
    if(ln && ln.type==="slant"){
      ln.x1 = Math.max(frame.x, Math.min(frame.x+frame.w, ln.x1));
      ln.x2 = Math.max(frame.x, Math.min(frame.x+frame.w, ln.x2));
      ln.y1 = Math.max(frame.y, Math.min(frame.y+frame.h, ln.y1));
      ln.y2 = Math.max(frame.y, Math.min(frame.y+frame.h, ln.y2));
    }
  }
}

/* -------- Delete (button + keys) -------- */
deleteBtn.onclick = ()=>{
  if(!selected) return;
  if(selected.type==="dot") dots.splice(selected.idx,1);
  if(selected.type==="line") lines.splice(selected.idx,1);
  selected = null;
};

window.addEventListener("keydown", e=>{
  if((e.key === "Delete" || e.key === "Backspace") && selected){
    if(selected.type==="dot") dots.splice(selected.idx,1);
    if(selected.type==="line") lines.splice(selected.idx,1);
    selected = null;
  }
});

/* -------- Modes -------- */
function setMode(m){
  mode = m;
  [dotBtn,vertBtn,horiBtn,slantBtn].forEach(b=>b.classList.remove("active"));
  if(m==="dot") dotBtn.classList.add("active");
  if(m==="vert") vertBtn.classList.add("active");
  if(m==="hori") horiBtn.classList.add("active");
  if(m==="slant") slantBtn.classList.add("active");
}
dotBtn.onclick = ()=>setMode("dot");
vertBtn.onclick = ()=>setMode("vert");
horiBtn.onclick = ()=>setMode("hori");
slantBtn.onclick = ()=>setMode("slant");

/* -------- Image Import -------- */
loadImgBtn.onclick = ()=> imgInput.click();
imgInput.onchange = e=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  const img = new Image();
  const url = URL.createObjectURL(file);
  img.onload = ()=>{
    bgImage = img;
    imgInput.value = "";
    // Hide welcome message
    document.getElementById("welcomeMsg").style.display = "none";
    // Performance: switch to full DPR for imported image
    document.body.classList.remove("camera-active");
    resizeCanvas();
  };
  img.onerror = ()=>{
    URL.revokeObjectURL(url);
    imgInput.value = "";
  };
  img.src = url;
};
clearImgBtn.onclick = ()=>{ 
  bgImage = null;
  bgImageCache = null; // Clear cache
  // Performance: restore camera mode
  if(!videoHidden) document.body.classList.add("camera-active");
  resizeCanvas();
};

/* -------- Camera toggle + BG cycling -------- */
const bgPalette = document.getElementById("bgPalette");

toggleCam.onclick = ()=>{
  videoHidden = !videoHidden;
  bgPalette.style.display = videoHidden ? "flex" : "none";
  
  // Performance: toggle blur and DPR based on camera state
  if(videoHidden || bgImage){
    document.body.classList.remove("camera-active");
  } else {
    document.body.classList.add("camera-active");
  }
  resizeCanvas();
};
  
switchBtn.onclick = switchCamera;
  
bgPalette.querySelectorAll("button").forEach(btn=>{
  btn.style.background = btn.dataset.bg;
  btn.onclick = ()=>{
    gridBg = btn.dataset.bg;
  };
});

/* -------- Frame FAB + Custom ratio -------- */
frameFab.onclick = ()=>{
  frameIndex = (frameIndex+1) % frameList.length;
  const f = frameList[frameIndex];
  frame.ratio = f.value;
  const labelSpan = frameFab.querySelector('.btn-label');
  const isMobile = window.innerWidth < 1024;
  
  if(labelSpan){
    // Mobile: show just ratio (e.g., "1:1"), Desktop: show "Frame: 1:1"
    labelSpan.textContent = isMobile ? f.label : 'Frame: ' + f.label;
  } else {
    frameFab.querySelector('.btn-icon').textContent = f.label;
  }
  currentRatioLabel.textContent = f.label;
  resizeCanvas();
};

customRatioBtn.onclick = ()=> modalCustom.style.display = "flex";
crClose.onclick = ()=> modalCustom.style.display = "none";
crApply.onclick = ()=>{
  const w = parseFloat(crW.value);
  const h = parseFloat(crH.value);
  if(!w || !h) return;
  let W = w, H = h;
  if(crUnit.value === "in"){ W *= 25.4; H *= 25.4; }
  const ratio = W / H;
  if(ratio > 0){
    frame.ratio = ratio;
    const labelSpan = frameFab.querySelector('.btn-label');
    const isMobile = window.innerWidth < 1024;
    
    if(labelSpan){
      // Mobile: show just ratio (e.g., "16:9"), Desktop: show "Frame: 16:9"
      labelSpan.textContent = isMobile ? `${w}:${h}` : `Frame: ${w}:${h}`;
    } else {
      frameFab.querySelector('.btn-icon').textContent = `${w}:${h}`;
    }
    currentRatioLabel.textContent = `${w}√ó${h}`;
    resizeCanvas();
  }
  modalCustom.style.display = "none";
};

/* -------- Help Hint -------- */
let helpHintEl = null;
let helpOverlayEl = null;
let helpTimer = null;
let helpActive = false;
const HOLD_MS = 420;

const helpTargets = [
  { el: loadImgBtn, label: "Load an image from your device" },
  { el: clearImgBtn, label: "Clear the loaded image" },
  { el: toggleCam, label: "Toggle camera on/off" },
  { el: switchBtn, label: "Switch between cameras" },
  { el: frameFab, label: "Cycle through frame ratios" },
  { el: customRatioBtn, label: "Set a custom aspect ratio" },
  { el: dotBtn, label: "Place guide dots" },
  { el: vertBtn, label: "Add vertical lines" },
  { el: horiBtn, label: "Add horizontal lines" },
  { el: slantBtn, label: "Add diagonal lines" },
  { el: deleteBtn, label: "Delete selected element" },
  { el: exportBtn, label: "Export the composition" }
];

function showHelp(){
  if(helpActive) return;
  helpActive = true;

  if(!helpOverlayEl){
    helpOverlayEl = document.createElement("div");
    helpOverlayEl.className = "help-overlay";
    document.body.appendChild(helpOverlayEl);
  }

  if(!helpHintEl){
    helpHintEl = document.createElement("div");
    helpHintEl.id = "helpHint";
    document.body.appendChild(helpHintEl);
  }

  helpHintEl.innerHTML = "";

  helpTargets.forEach((t)=>{
    if(!t.el) return;
    const rect = t.el.getBoundingClientRect();
    const lbl = document.createElement("div");
    lbl.className = "help-label";
    lbl.textContent = t.label;
    
    const screenMid = window.innerHeight / 2;
    
    // Check if we're on desktop (1024px+)
    const isDesktop = window.innerWidth >= 1024;
    
    if(isDesktop){
      // Desktop: horizontal labels
      lbl.style.left = rect.left + rect.width/2 + "px";
      lbl.style.top = (rect.top < screenMid ? rect.bottom + 8 : rect.top - 38) + "px";
    } else {
      // Mobile: vertical rotated labels
      lbl.style.left = rect.left + rect.width/2 + 38 + (t.dx || 0) + "px";
      lbl.style.top = (rect.top < screenMid ? rect.bottom + 192 : rect.top - 60) + "px";
    }
    
    helpHintEl.appendChild(lbl);
  });

  helpOverlayEl.addEventListener("pointerdown", hideHelp);
  helpOverlayEl.addEventListener("touchstart", hideHelp);
}

function hideHelp(){
  clearTimeout(helpTimer);
  helpTimer = null;
  helpActive = false;
  if(helpHintEl){
    helpHintEl.remove();
    helpHintEl = null;
  }
  if(helpOverlayEl){
    helpOverlayEl.remove();
    helpOverlayEl = null;
  }
}

// Help button behavior
// Mobile: click = card, touch-hold = hints
// Desktop: left-click = card, right-click = hints

helpBtn.addEventListener("click", (e)=>{
  if(e.button !== 0) return; // Only left click
  e.preventDefault();
  e.stopPropagation();
  clearTimeout(helpTimer);
  const helpCard = document.getElementById("helpCard");
  const helpCardOverlay = document.getElementById("helpCardOverlay");
  helpCard.style.display = "block";
  helpCardOverlay.style.display = "block";
});

// Right-click for tool hints on desktop
helpBtn.addEventListener("contextmenu", (e)=>{
  e.preventDefault();
  e.stopPropagation();
  showHelp();
  
  // Auto-hide after 3 seconds on right-click
  setTimeout(hideHelp, 3000);
});

// Touch and hold for hints on mobile
helpBtn.addEventListener("touchstart", (e)=>{
  e.preventDefault();
  e.stopPropagation();
  helpTimer = setTimeout(()=>{
    showHelp();
  }, HOLD_MS);
}, { passive: false });

helpBtn.addEventListener("touchend", (e)=>{
  if(helpActive){
    hideHelp();
  }
});

helpBtn.addEventListener("touchcancel", ()=>{
  clearTimeout(helpTimer);
  if(helpActive) hideHelp();
});

// Close help card
const helpCardClose = document.getElementById("helpCardClose");
const helpCardOverlay = document.getElementById("helpCardOverlay");

helpCardClose.addEventListener("click", ()=>{
  document.getElementById("helpCard").style.display = "none";
  helpCardOverlay.style.display = "none";
});

helpCardOverlay.addEventListener("click", ()=>{
  document.getElementById("helpCard").style.display = "none";
  helpCardOverlay.style.display = "none";
});

/* -------- Export -------- */
exportBtn.onclick = ()=>{
  const wasHelpActive = helpActive;
  if(wasHelpActive) hideHelp();

  const data = canvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = data;
  a.download = "composition.png";
  a.click();
};

/* -------- Init -------- */
(async function init(){
  await getDevices();
  await startCamera();
  frame.ratio = 1;
  
  // Performance: Set camera-active class initially
  document.body.classList.add("camera-active");
  
  resizeCanvas();
  draw();
  
  // Set correct button text based on screen size
  const isMobile = window.innerWidth < 1024;
  const frameLabelSpan = frameFab.querySelector('.btn-label');
  const customLabelSpan = customRatioBtn.querySelector('.btn-label');
  
  if(frameLabelSpan){
    frameLabelSpan.textContent = isMobile ? '1:1' : 'Frame: 1:1';
  }
  
  if(customLabelSpan){
    customLabelSpan.textContent = isMobile ? 'Custom' : 'Custom Frame';
  }
})();
  if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    navigator.serviceWorker.register("./sw.js");
  });
}


</script>

</body>
</html>
